// FeatureExecutor.swift
// GherkinTesting
//
// Copyright Â© 2026 Atelier Socle. MIT License.

import Foundation
import Testing

/// Groups a caller's source location for issue reporting.
///
/// Used by ``FeatureExecutor`` to construct `SourceLocation` values pointing
/// to the Swift source or `.feature` file where a step is defined.
public struct CallerLocation: Sendable {
    /// The caller's `#fileID`.
    public let fileID: String

    /// The caller's `#filePath`.
    public let filePath: String

    /// The caller's `#line`.
    public let line: Int

    /// The caller's `#column`.
    public let column: Int

    /// Creates a caller location.
    ///
    /// - Parameters:
    ///   - fileID: The caller's file ID.
    ///   - filePath: The caller's file path.
    ///   - line: The caller's line number.
    ///   - column: The caller's column number.
    public init(fileID: String, filePath: String, line: Int, column: Int) {
        self.fileID = fileID
        self.filePath = filePath
        self.line = line
        self.column = column
    }
}

/// Runtime bridge between macro-generated test code and the execution engine.
///
/// `FeatureExecutor` is called by the `@Test` methods generated by `@Feature`.
/// It parses the Gherkin source, compiles it into pickles, and runs them
/// against the provided step definitions using ``TestRunner``.
///
/// Step failures are reported directly to Swift Testing via `Issue.record()`
/// with a `SourceLocation` pointing to the `.feature` file and step line
/// for `.file()` sources, or the caller's Swift source location for `.inline()`.
///
/// ```swift
/// // Generated by @Feature macro:
/// try await FeatureExecutor<LoginFeature>.run(
///     source: .inline("Feature: Login\n  Scenario: ..."),
///     definitions: LoginFeature.__stepDefinitions,
///     featureFactory: { LoginFeature() }
/// )
/// ```
public struct FeatureExecutor<F: GherkinFeature>: Sendable {

    /// Extracts the step's AST line and column from its pickle node ID.
    ///
    /// The ``PickleCompiler`` encodes the original AST location as `"line:column"`
    /// in ``PickleStep/astNodeIds``.
    ///
    /// - Parameter step: The pickle step.
    /// - Returns: A tuple of (line, column), or `nil` if the format is unexpected.
    public static func extractStepLine(from step: PickleStep) -> (line: Int, column: Int)? {
        guard let nodeId = step.astNodeIds.first else { return nil }
        let parts = nodeId.split(separator: ":")
        guard parts.count == 2,
            let line = Int(parts[0]),
            let column = Int(parts[1])
        else { return nil }
        return (line, column)
    }

    /// Builds a `Testing.SourceLocation` pointing to a step in the Gherkin source.
    ///
    /// For `.file()` sources, the location points to the `.feature` file at the step's line.
    /// For `.inline()` sources, the location uses the caller's Swift source location.
    ///
    /// - Parameters:
    ///   - step: The pickle step whose location to resolve.
    ///   - source: The feature source (.file or .inline).
    ///   - caller: The caller's source location.
    /// - Returns: A `SourceLocation` pointing to either the .feature file or the caller.
    public static func buildStepSourceLocation(
        for step: PickleStep,
        source: FeatureSource,
        caller: CallerLocation
    ) -> SourceLocation {
        switch source {
        case .file(let path):
            if let loc = extractStepLine(from: step) {
                // fileID must be well-formed (#fileID format: "Module/File"),
                // line and column must be > 0.
                let featureFileID = path.contains("/") ? path : "GherkinFeature/\(path)"
                return SourceLocation(
                    fileID: featureFileID,
                    filePath: path,
                    line: max(loc.line, 1),
                    column: max(loc.column, 1)
                )
            }
            return SourceLocation(
                fileID: caller.fileID,
                filePath: caller.filePath,
                line: caller.line,
                column: caller.column
            )
        case .inline:
            return SourceLocation(
                fileID: caller.fileID,
                filePath: caller.filePath,
                line: caller.line,
                column: caller.column
            )
        }
    }

    /// Parses, compiles, and executes a Gherkin feature.
    ///
    /// Step failures are reported directly to Swift Testing via `Issue.record()`
    /// with source locations pointing to the `.feature` file for `.file()` sources.
    ///
    /// - Parameters:
    ///   - source: The Gherkin source (inline string or file path).
    ///   - definitions: The step definitions to match against.
    ///   - hooks: Optional lifecycle hooks. Defaults to empty.
    ///   - bundle: Optional bundle for resolving `.file()` paths. When `nil`,
    ///     falls back to `Bundle.main`. Macro-generated code passes `Bundle.module`.
    ///   - configuration: Optional execution configuration. Defaults to `.default`.
    ///   - scenarioFilter: Optional scenario name filter. When set, only scenarios
    ///     whose name matches this string are executed.
    ///   - fileID: The caller's file ID (captured automatically).
    ///   - filePath: The caller's file path (captured automatically).
    ///   - line: The caller's line number (captured automatically).
    ///   - column: The caller's column number (captured automatically).
    ///   - reports: Report formats to auto-write after execution. Each format
    ///     produces a file at either a default path (`/tmp/swift-gherkin-testing/reports/`)
    ///     or a custom path. Defaults to empty (no reports written).
    ///   - featureFactory: A closure that creates a fresh feature instance.
    /// - Returns: The ``TestRunResult`` containing all execution results.
    /// - Throws: ``ParserError`` if the source is malformed,
    ///   or any error from step execution.
    @discardableResult
    public static func run(
        source: FeatureSource,
        definitions: [StepDefinition<F>],
        hooks: HookRegistry = HookRegistry(),
        bundle: Bundle? = nil,
        configuration: GherkinConfiguration = .default,
        scenarioFilter: String? = nil,
        fileID: String = #fileID,
        filePath: String = #filePath,
        line: Int = #line,
        column: Int = #column,
        reports: [ReportFormat] = [],
        featureFactory: @Sendable () -> F
    ) async throws -> TestRunResult {
        let gherkinSource: String

        switch source {
        case .inline(let text):
            gherkinSource = text
        case .file(let path):
            gherkinSource = try loadFile(at: path, bundle: bundle)
        }

        // Parse
        let parser = GherkinParser()
        let document = try parser.parse(source: gherkinSource)

        // Compile
        let compiler = PickleCompiler()
        var pickles = compiler.compile(document)

        // Apply scenario filter if set
        if let filter = scenarioFilter {
            pickles = pickles.filter { $0.name == filter }
        }

        // Extract feature metadata
        let featureName = document.feature?.name ?? "Unknown Feature"
        let featureTags = document.feature?.tags.map(\.name) ?? []

        // Create report writers from reports: parameter (before runner.run)
        var effectiveConfig = configuration
        let reportOutputs = buildReportOutputs(from: reports, config: &effectiveConfig)

        // Run
        let runner = TestRunner<F>(
            definitions: definitions,
            hooks: hooks,
            configuration: effectiveConfig
        )

        let feature = featureFactory()
        let result = try await runner.run(
            pickles: pickles,
            featureName: featureName,
            featureTags: featureTags,
            feature: feature
        )

        // Report failures via Testing.Issue.record() with SourceLocation
        let caller = CallerLocation(fileID: fileID, filePath: filePath, line: line, column: column)
        reportIssues(from: result, source: source, dryRun: configuration.dryRun, caller: caller)

        // Write report files (failures silently ignored â€” must not break the test)
        await writeReportOutputs(reportOutputs)

        return result
    }

    /// Creates reporter instances from ``ReportFormat`` values and appends them to the configuration.
    ///
    /// - Parameters:
    ///   - reports: The report formats to create.
    ///   - config: The configuration to append reporters to (mutated in place).
    /// - Returns: An array of (reporter, outputPath) pairs for writing after execution.
    private static func buildReportOutputs(
        from reports: [ReportFormat],
        config: inout GherkinConfiguration
    ) -> [(reporter: any GherkinReporter, path: String)] {
        guard !reports.isEmpty else { return [] }
        let structName = String(describing: F.self)
        let defaultDir = "/tmp/swift-gherkin-testing/reports"
        var outputs: [(reporter: any GherkinReporter, path: String)] = []
        for format in reports {
            let reporter: any GherkinReporter
            let path: String
            switch format.kind {
            case .html:
                reporter = HTMLReporter()
                path = format.customPath ?? "\(defaultDir)/\(structName).html"
            case .json:
                reporter = CucumberJSONReporter()
                path = format.customPath ?? "\(defaultDir)/\(structName).json"
            case .junitXML:
                reporter = JUnitXMLReporter()
                path = format.customPath ?? "\(defaultDir)/\(structName).xml"
            }
            outputs.append((reporter, path))
            config.reporters.append(reporter)
        }
        return outputs
    }

    /// Writes report files to disk. Failures are silently ignored.
    ///
    /// - Parameter outputs: The (reporter, path) pairs to write.
    private static func writeReportOutputs(
        _ outputs: [(reporter: any GherkinReporter, path: String)]
    ) async {
        for (reporter, path) in outputs {
            let url = URL(fileURLWithPath: path)
            do {
                try FileManager.default.createDirectory(
                    at: url.deletingLastPathComponent(),
                    withIntermediateDirectories: true
                )
                try await reporter.writeReport(to: url)
                print("ðŸ“Š Report written: \(path)")
            } catch {
                // Write failures must not break the test.
            }
        }
    }

    /// Reports step failures, undefined steps, and ambiguous steps to Swift Testing.
    ///
    /// Each issue is recorded with a `SourceLocation` pointing to the step's
    /// location in the `.feature` file (for `.file()` sources) or the caller's
    /// Swift source location (for `.inline()` sources).
    ///
    /// In dry-run mode, undefined and ambiguous steps are not reported as issues
    /// since dry-run is used for discovery, not failure detection.
    ///
    /// - Parameters:
    ///   - result: The test run result to inspect.
    ///   - source: The feature source (.file or .inline).
    ///   - dryRun: Whether the run was in dry-run mode.
    ///   - caller: The caller's source location.
    private static func reportIssues(
        from result: TestRunResult,
        source: FeatureSource,
        dryRun: Bool,
        caller: CallerLocation
    ) {
        for featureResult in result.featureResults {
            for scenarioResult in featureResult.scenarioResults {
                for stepResult in scenarioResult.stepResults {
                    let loc = buildStepSourceLocation(
                        for: stepResult.step,
                        source: source,
                        caller: caller
                    )

                    switch stepResult.status {
                    case .failed(let failure):
                        Issue.record(
                            Testing.Comment(
                                rawValue: "Step failed in \(scenarioResult.name): "
                                    + "\(stepResult.step.text) â€” \(failure.message)"
                            ),
                            sourceLocation: loc
                        )
                    case .undefined:
                        if !dryRun {
                            Issue.record(
                                Testing.Comment(
                                    rawValue: "Undefined step in \(scenarioResult.name): "
                                        + "\(stepResult.step.text)"
                                ),
                                sourceLocation: loc
                            )
                        }
                    case .ambiguous:
                        if !dryRun {
                            Issue.record(
                                Testing.Comment(
                                    rawValue: "Ambiguous step in \(scenarioResult.name): "
                                        + "\(stepResult.step.text)"
                                ),
                                sourceLocation: loc
                            )
                        }
                    default:
                        break
                    }
                }
            }
        }
    }

    /// Loads a `.feature` file from disk.
    ///
    /// Resolves the path relative to the given bundle (or `Bundle.main` as fallback)
    /// if not absolute.
    ///
    /// - Parameters:
    ///   - path: The file path.
    ///   - bundle: The bundle to search for relative paths. Falls back to `Bundle.main`.
    /// - Returns: The file contents as a string.
    /// - Throws: If the file cannot be read.
    private static func loadFile(at path: String, bundle: Bundle?) throws -> String {
        let url: URL
        if path.hasPrefix("/") {
            url = URL(fileURLWithPath: path)
        } else if let resolvedPath = (bundle ?? Bundle.main).path(forResource: path, ofType: nil) {
            url = URL(fileURLWithPath: resolvedPath)
        } else {
            url = URL(fileURLWithPath: path)
        }
        return try String(contentsOf: url, encoding: .utf8)
    }
}

/// An error thrown when a feature execution encounters failures or undefined steps.
///
/// Contains a list of failure descriptions for diagnostic reporting.
public struct FeatureExecutionError: Error, Sendable, LocalizedError {
    /// The failure descriptions.
    public let failures: [String]

    /// A localized description joining all failure messages.
    public var errorDescription: String? {
        "Feature execution failed:\n" + failures.map { "  - \($0)" }.joined(separator: "\n")
    }
}
