// FeatureExecutor.swift
// GherkinTesting
//
// Copyright © 2026 Atelier Socle. MIT License.

import Foundation
import Testing

/// Runtime bridge between macro-generated test code and the execution engine.
///
/// `FeatureExecutor` is called by the `@Test` methods generated by `@Feature`.
/// It parses the Gherkin source, compiles it into pickles, and runs them
/// against the provided step definitions using ``TestRunner``.
///
/// Step failures are reported directly to Swift Testing via `Issue.record()`
/// with a `SourceLocation` pointing to the `.feature` file and step line
/// for `.file()` sources, or the caller's Swift source location for `.inline()`.
///
/// ```swift
/// // Generated by @Feature macro:
/// try await FeatureExecutor<LoginFeature>.run(
///     source: .inline("Feature: Login\n  Scenario: ..."),
///     definitions: LoginFeature.__stepDefinitions,
///     featureFactory: { LoginFeature() }
/// )
/// ```
public struct FeatureExecutor<F: GherkinFeature>: Sendable {

    /// Extracts the step's AST line and column from its pickle node ID.
    ///
    /// The ``PickleCompiler`` encodes the original AST location as `"line:column"`
    /// in ``PickleStep/astNodeIds``.
    ///
    /// - Parameter step: The pickle step.
    /// - Returns: A tuple of (line, column), or `nil` if the format is unexpected.
    public static func extractStepLine(from step: PickleStep) -> (line: Int, column: Int)? {
        guard let nodeId = step.astNodeIds.first else { return nil }
        let parts = nodeId.split(separator: ":")
        guard parts.count == 2,
              let line = Int(parts[0]),
              let column = Int(parts[1]) else { return nil }
        return (line, column)
    }

    /// Builds a `Testing.SourceLocation` pointing to a step in the Gherkin source.
    ///
    /// For `.file()` sources, the location points to the `.feature` file at the step's line.
    /// For `.inline()` sources, the location uses the caller's Swift source location.
    ///
    /// - Parameters:
    ///   - step: The pickle step whose location to resolve.
    ///   - source: The feature source (.file or .inline).
    ///   - callerFileID: The caller's `#fileID`.
    ///   - callerFilePath: The caller's `#filePath`.
    ///   - callerLine: The caller's `#line`.
    ///   - callerColumn: The caller's `#column`.
    /// - Returns: A `SourceLocation` pointing to either the .feature file or the caller.
    public static func buildStepSourceLocation(
        for step: PickleStep,
        source: FeatureSource,
        callerFileID: String,
        callerFilePath: String,
        callerLine: Int,
        callerColumn: Int
    ) -> SourceLocation {
        switch source {
        case .file(let path):
            if let loc = extractStepLine(from: step) {
                // fileID must be well-formed (#fileID format: "Module/File"),
                // line and column must be > 0.
                let featureFileID = path.contains("/") ? path : "GherkinFeature/\(path)"
                return SourceLocation(
                    fileID: featureFileID,
                    filePath: path,
                    line: max(loc.line, 1),
                    column: max(loc.column, 1)
                )
            }
            return SourceLocation(
                fileID: callerFileID,
                filePath: callerFilePath,
                line: callerLine,
                column: callerColumn
            )
        case .inline:
            return SourceLocation(
                fileID: callerFileID,
                filePath: callerFilePath,
                line: callerLine,
                column: callerColumn
            )
        }
    }

    /// Parses, compiles, and executes a Gherkin feature.
    ///
    /// Step failures are reported directly to Swift Testing via `Issue.record()`
    /// with source locations pointing to the `.feature` file for `.file()` sources.
    ///
    /// - Parameters:
    ///   - source: The Gherkin source (inline string or file path).
    ///   - definitions: The step definitions to match against.
    ///   - hooks: Optional lifecycle hooks. Defaults to empty.
    ///   - bundle: Optional bundle for resolving `.file()` paths. When `nil`,
    ///     falls back to `Bundle.main`. Macro-generated code passes `Bundle.module`.
    ///   - configuration: Optional execution configuration. Defaults to `.default`.
    ///   - scenarioFilter: Optional scenario name filter. When set, only scenarios
    ///     whose name matches this string are executed.
    ///   - fileID: The caller's file ID (captured automatically).
    ///   - filePath: The caller's file path (captured automatically).
    ///   - line: The caller's line number (captured automatically).
    ///   - column: The caller's column number (captured automatically).
    ///   - featureFactory: A closure that creates a fresh feature instance.
    /// - Throws: ``ParserError`` if the source is malformed,
    ///   or any error from step execution.
    public static func run(
        source: FeatureSource,
        definitions: [StepDefinition<F>],
        hooks: HookRegistry = HookRegistry(),
        bundle: Bundle? = nil,
        configuration: GherkinConfiguration = .default,
        scenarioFilter: String? = nil,
        fileID: String = #fileID,
        filePath: String = #filePath,
        line: Int = #line,
        column: Int = #column,
        featureFactory: @Sendable () -> F
    ) async throws {
        let gherkinSource: String

        switch source {
        case .inline(let text):
            gherkinSource = text
        case .file(let path):
            gherkinSource = try loadFile(at: path, bundle: bundle)
        }

        // Parse
        let parser = GherkinParser()
        let document = try parser.parse(source: gherkinSource)

        // Compile
        let compiler = PickleCompiler()
        var pickles = compiler.compile(document)

        // Apply scenario filter if set
        if let filter = scenarioFilter {
            pickles = pickles.filter { $0.name == filter }
        }

        // Extract feature metadata
        let featureName = document.feature?.name ?? "Unknown Feature"
        let featureTags = document.feature?.tags.map(\.name) ?? []

        // Run
        let runner = TestRunner<F>(
            definitions: definitions,
            hooks: hooks,
            configuration: configuration
        )

        let feature = featureFactory()
        let result = try await runner.run(
            pickles: pickles,
            featureName: featureName,
            featureTags: featureTags,
            feature: feature
        )

        // Report failures via Testing.Issue.record() with SourceLocation
        reportIssues(
            from: result,
            source: source,
            callerFileID: fileID,
            callerFilePath: filePath,
            callerLine: line,
            callerColumn: column
        )
    }

    /// Reports step failures, undefined steps, and ambiguous steps to Swift Testing.
    ///
    /// Each issue is recorded with a `SourceLocation` pointing to the step's
    /// location in the `.feature` file (for `.file()` sources) or the caller's
    /// Swift source location (for `.inline()` sources).
    private static func reportIssues(
        from result: TestRunResult,
        source: FeatureSource,
        callerFileID: String,
        callerFilePath: String,
        callerLine: Int,
        callerColumn: Int
    ) {
        for featureResult in result.featureResults {
            for scenarioResult in featureResult.scenarioResults {
                for stepResult in scenarioResult.stepResults {
                    let loc = buildStepSourceLocation(
                        for: stepResult.step,
                        source: source,
                        callerFileID: callerFileID,
                        callerFilePath: callerFilePath,
                        callerLine: callerLine,
                        callerColumn: callerColumn
                    )

                    switch stepResult.status {
                    case .failed(let failure):
                        Issue.record(
                            Testing.Comment(
                                rawValue: "Step failed in \(scenarioResult.name): "
                                + "\(stepResult.step.text) — \(failure.message)"
                            ),
                            sourceLocation: loc
                        )
                    case .undefined:
                        Issue.record(
                            Testing.Comment(
                                rawValue: "Undefined step in \(scenarioResult.name): "
                                + "\(stepResult.step.text)"
                            ),
                            sourceLocation: loc
                        )
                    case .ambiguous:
                        Issue.record(
                            Testing.Comment(
                                rawValue: "Ambiguous step in \(scenarioResult.name): "
                                + "\(stepResult.step.text)"
                            ),
                            sourceLocation: loc
                        )
                    default:
                        break
                    }
                }
            }
        }
    }

    /// Loads a `.feature` file from disk.
    ///
    /// Resolves the path relative to the given bundle (or `Bundle.main` as fallback)
    /// if not absolute.
    ///
    /// - Parameters:
    ///   - path: The file path.
    ///   - bundle: The bundle to search for relative paths. Falls back to `Bundle.main`.
    /// - Returns: The file contents as a string.
    /// - Throws: If the file cannot be read.
    private static func loadFile(at path: String, bundle: Bundle?) throws -> String {
        let url: URL
        if path.hasPrefix("/") {
            url = URL(fileURLWithPath: path)
        } else if let resolvedPath = (bundle ?? Bundle.main).path(forResource: path, ofType: nil) {
            url = URL(fileURLWithPath: resolvedPath)
        } else {
            url = URL(fileURLWithPath: path)
        }
        return try String(contentsOf: url, encoding: .utf8)
    }
}

/// An error thrown when a feature execution encounters failures or undefined steps.
///
/// Contains a list of failure descriptions for diagnostic reporting.
public struct FeatureExecutionError: Error, Sendable, LocalizedError {
    /// The failure descriptions.
    public let failures: [String]

    /// A localized description joining all failure messages.
    public var errorDescription: String? {
        "Feature execution failed:\n" + failures.map { "  - \($0)" }.joined(separator: "\n")
    }
}
